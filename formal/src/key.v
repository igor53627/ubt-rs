(* Generated by rocq-of-rust *)
Require Import RocqOfRust.RocqOfRust.

Module key.
  Definition value_STEM_LEN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 31 |))).
  
  Global Instance Instance_IsConstant_value_STEM_LEN :
    M.IsFunction.C "ubt::key::STEM_LEN" value_STEM_LEN.
  Admitted.
  Global Typeclasses Opaque value_STEM_LEN.
  
  Definition value_SUBINDEX_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 8 |))).
  
  Global Instance Instance_IsConstant_value_SUBINDEX_BITS :
    M.IsFunction.C "ubt::key::SUBINDEX_BITS" value_SUBINDEX_BITS.
  Admitted.
  Global Typeclasses Opaque value_SUBINDEX_BITS.
  
  (* StructTuple
    {
      name := "Stem";
      const_params := [];
      ty_params := [];
      fields :=
        [
          Ty.apply
            (Ty.path "array")
            [ M.unevaluated_const (mk_str (| "ubt_key_Stem_0_discriminant" |)) ]
            [ Ty.path "u8" ]
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], self |) in
          M.match_operator (|
            Ty.path "ubt::key::Stem",
            Value.DeclaredButUndefined,
            [ fun γ => ltac:(M.monadic (M.read (| M.deref (| M.read (| self |) |) |))) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_ubt_key_Stem.
  
  Module Impl_core_marker_Copy_for_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_ubt_key_Stem.
  
  Module Impl_core_marker_StructuralPartialEq_for_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_ubt_key_Stem.
  
  Module Impl_core_cmp_PartialEq_ubt_key_Stem_for_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], self |) in
          let other :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 31 ] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 31 ] [ Ty.path "u8" ]
              ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "ubt::key::Stem",
                  0
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "ubt::key::Stem",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "ubt::key::Stem" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_ubt_key_Stem_for_ubt_key_Stem.
  
  Module Impl_core_cmp_Eq_for_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], self |) in
          M.match_operator (|
            Ty.tuple [],
            Value.DeclaredButUndefined,
            [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_ubt_key_Stem.
  
  Module Impl_core_hash_Hash_for_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], self |) in
          let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 31 ] [ Ty.path "u8" ],
              [],
              [],
              "hash",
              [],
              [ __H ]
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "ubt::key::Stem",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_ubt_key_Stem.
  
  Module Impl_core_default_Default_for_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "ubt::key::Stem"
            []
            []
            [
              M.call_closure (|
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 31 ] [ Ty.path "u8" ],
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 31 ]
                    [ Ty.path "u8" ],
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_ubt_key_Stem.
  
  Module Impl_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    (*
        pub const fn new(bytes: [u8; STEM_LEN]) -> Self {
            Self(bytes)
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes :=
            M.alloc (|
              Ty.apply
                (Ty.path "array")
                [ M.unevaluated_const (mk_str (| "ubt_key_new_discriminant" |)) ]
                [ Ty.path "u8" ],
              bytes
            |) in
          Value.StructTuple "ubt::key::Stem" [] [] [ M.read (| bytes |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn from_slice(slice: &[u8]) -> Self {
            let mut bytes = [0u8; STEM_LEN];
            bytes.copy_from_slice(slice);
            Self(bytes)
        }
    *)
    Definition from_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              slice
            |) in
          M.read (|
            let~ bytes :
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 31 ]
                  [ Ty.path "u8" ] :=
              lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 31 |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "copy_from_slice",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 31 ]
                            [ Ty.path "u8" ]
                        ])
                      (Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                    [ M.borrow (| Pointer.Kind.MutRef, bytes |) ]
                  |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |)
                ]
              |) in
            M.alloc (|
              Ty.path "ubt::key::Stem",
              Value.StructTuple "ubt::key::Stem" [] [] [ M.read (| bytes |) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_slice :
      M.IsAssociatedFunction.C Self "from_slice" from_slice.
    Admitted.
    Global Typeclasses Opaque from_slice.
    
    (*
        pub const fn as_bytes(&self) -> &[u8; STEM_LEN] {
            &self.0
        }
    *)
    Definition as_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "ubt::key::Stem",
                  0
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_bytes : M.IsAssociatedFunction.C Self "as_bytes" as_bytes.
    Admitted.
    Global Typeclasses Opaque as_bytes.
    
    (*
        pub fn is_zero(&self) -> bool {
            self.0.iter().all(|&b| b == 0)
        }
    *)
    Definition is_zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
              [],
              [],
              "all",
              [],
              [ Ty.function [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ] (Ty.path "bool") ]
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.alloc (|
                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
                  M.call_closure (|
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "iter",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 31 ]
                                [ Ty.path "u8" ]
                            ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "ubt::key::Stem",
                              0
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |)
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.path "bool",
                          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u8" ], α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.deref (| M.read (| γ |) |) in
                                let b := M.copy (| Ty.path "u8", γ |) in
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| b |); Value.Integer IntegerKind.U8 0 ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_zero : M.IsAssociatedFunction.C Self "is_zero" is_zero.
    Admitted.
    Global Typeclasses Opaque is_zero.
    
    (*
        pub fn bit_at(&self, pos: usize) -> bool {
            debug_assert!(pos < STEM_LEN * 8);
            let byte_idx = pos / 8;
            let bit_idx = 7 - (pos % 8); // MSB first
            (self.0[byte_idx] >> bit_idx) & 1 == 1
        }
    *)
    Definition bit_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; pos ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], self |) in
          let pos := M.alloc (| Ty.path "usize", pos |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.read (|
                        let~ _ : Ty.tuple [] :=
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        M.call_closure (|
                                          Ty.path "bool",
                                          UnOp.not,
                                          [
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.read (| pos |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  BinOp.Wrap.mul,
                                                  [
                                                    M.read (|
                                                      get_constant (|
                                                        "ubt::key::STEM_LEN",
                                                        Ty.path "usize"
                                                      |)
                                                    |);
                                                    Value.Integer IntegerKind.Usize 8
                                                  ]
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "assertion failed: pos < STEM_LEN * 8" |) ]
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |) in
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)
                      |)));
                  fun γ => ltac:(M.monadic (Value.Tuple []))
                ]
              |) in
            let~ byte_idx : Ty.path "usize" :=
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.div,
                [ M.read (| pos |); Value.Integer IntegerKind.Usize 8 ]
              |) in
            let~ bit_idx : Ty.path "usize" :=
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.sub,
                [
                  Value.Integer IntegerKind.Usize 7;
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.rem,
                    [ M.read (| pos |); Value.Integer IntegerKind.Usize 8 ]
                  |)
                ]
              |) in
            M.alloc (|
              Ty.path "bool",
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.call_closure (|
                    Ty.path "u8",
                    BinOp.Wrap.bit_and,
                    [
                      M.call_closure (|
                        Ty.path "u8",
                        BinOp.Wrap.shr,
                        [
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "ubt::key::Stem",
                                0
                              |),
                              M.read (| byte_idx |)
                            |)
                          |);
                          M.read (| bit_idx |)
                        ]
                      |);
                      Value.Integer IntegerKind.U8 1
                    ]
                  |);
                  Value.Integer IntegerKind.U8 1
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_bit_at : M.IsAssociatedFunction.C Self "bit_at" bit_at.
    Admitted.
    Global Typeclasses Opaque bit_at.
    
    (*
        pub fn first_differing_bit(&self, other: &Self) -> Option<usize> {
            for i in 0..STEM_LEN {
                if self.0[i] != other.0[i] {
                    let xor = self.0[i] ^ other.0[i];
                    let bit_in_byte = 7 - xor.leading_zeros() as usize;
                    return Some(i * 8 + (7 - bit_in_byte));
                }
            }
            None
        }
    *)
    Definition first_differing_bit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], self |) in
          let other :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], other |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.use
                      (M.alloc (|
                        Ty.tuple [],
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (|
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            M.call_closure (|
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [
                                Value.mkStructRecord
                                  "core::ops::range::Range"
                                  []
                                  [ Ty.path "usize" ]
                                  [
                                    ("start", Value.Integer IntegerKind.Usize 0);
                                    ("end_",
                                      M.read (|
                                        get_constant (| "ubt::key::STEM_LEN", Ty.path "usize" |)
                                      |))
                                  ]
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    γ
                                  |) in
                                M.read (|
                                  M.loop (|
                                    Ty.tuple [],
                                    ltac:(M.monadic
                                      (let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ],
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "usize" ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::ops::range::Range")
                                                  []
                                                  [ Ty.path "usize" ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.MutRef, iter |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.never_to_any (| M.read (| M.break (||) |) |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                                M.match_operator (|
                                                  Ty.tuple [],
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              Ty.path "bool",
                                                              M.call_closure (|
                                                                Ty.path "bool",
                                                                BinOp.ne,
                                                                [
                                                                  M.read (|
                                                                    M.SubPointer.get_array_field (|
                                                                      M.SubPointer.get_struct_tuple_field (|
                                                                        M.deref (|
                                                                          M.read (| self |)
                                                                        |),
                                                                        "ubt::key::Stem",
                                                                        0
                                                                      |),
                                                                      M.read (| i |)
                                                                    |)
                                                                  |);
                                                                  M.read (|
                                                                    M.SubPointer.get_array_field (|
                                                                      M.SubPointer.get_struct_tuple_field (|
                                                                        M.deref (|
                                                                          M.read (| other |)
                                                                        |),
                                                                        "ubt::key::Stem",
                                                                        0
                                                                      |),
                                                                      M.read (| i |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.never_to_any (|
                                                          M.read (|
                                                            let~ xor : Ty.path "u8" :=
                                                              M.call_closure (|
                                                                Ty.path "u8",
                                                                BinOp.Wrap.bit_xor,
                                                                [
                                                                  M.read (|
                                                                    M.SubPointer.get_array_field (|
                                                                      M.SubPointer.get_struct_tuple_field (|
                                                                        M.deref (|
                                                                          M.read (| self |)
                                                                        |),
                                                                        "ubt::key::Stem",
                                                                        0
                                                                      |),
                                                                      M.read (| i |)
                                                                    |)
                                                                  |);
                                                                  M.read (|
                                                                    M.SubPointer.get_array_field (|
                                                                      M.SubPointer.get_struct_tuple_field (|
                                                                        M.deref (|
                                                                          M.read (| other |)
                                                                        |),
                                                                        "ubt::key::Stem",
                                                                        0
                                                                      |),
                                                                      M.read (| i |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |) in
                                                            let~ bit_in_byte : Ty.path "usize" :=
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.sub,
                                                                [
                                                                  Value.Integer IntegerKind.Usize 7;
                                                                  M.cast
                                                                    (Ty.path "usize")
                                                                    (M.call_closure (|
                                                                      Ty.path "u32",
                                                                      M.get_associated_function (|
                                                                        Ty.path "u8",
                                                                        "leading_zeros",
                                                                        [],
                                                                        []
                                                                      |),
                                                                      [ M.read (| xor |) ]
                                                                    |))
                                                                ]
                                                              |) in
                                                            M.return_ (|
                                                              Value.StructTuple
                                                                "core::option::Option::Some"
                                                                []
                                                                [ Ty.path "usize" ]
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.path "usize",
                                                                    BinOp.Wrap.add,
                                                                    [
                                                                      M.call_closure (|
                                                                        Ty.path "usize",
                                                                        BinOp.Wrap.mul,
                                                                        [
                                                                          M.read (| i |);
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            8
                                                                        ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        Ty.path "usize",
                                                                        BinOp.Wrap.sub,
                                                                        [
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            7;
                                                                          M.read (| bit_in_byte |)
                                                                        ]
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                  |)
                                |)))
                          ]
                        |)
                      |))
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                  Value.StructTuple "core::option::Option::None" [] [ Ty.path "usize" ] []
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_first_differing_bit :
      M.IsAssociatedFunction.C Self "first_differing_bit" first_differing_bit.
    Admitted.
    Global Typeclasses Opaque first_differing_bit.
  End Impl_ubt_key_Stem.
  
  Module Impl_core_fmt_Debug_for_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "Stem(0x{})", hex::encode(self.0))
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::Stem" ], self |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 2 ]
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                          Value.Array [ mk_str (| "Stem(0x" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 1 ]
                            [ Ty.path "core::fmt::rt::Argument" ],
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "alloc::string::String" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.path "alloc::string::String",
                                          M.call_closure (|
                                            Ty.path "alloc::string::String",
                                            M.get_function (|
                                              "hex::encode",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 31 ]
                                                  [ Ty.path "u8" ]
                                              ]
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_tuple_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "ubt::key::Stem",
                                                  0
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_ubt_key_Stem.
  
  Module Impl_core_convert_From_array_expr_u8_for_ubt_key_Stem.
    Definition Self : Ty.t := Ty.path "ubt::key::Stem".
    
    (*
        fn from(bytes: [u8; STEM_LEN]) -> Self {
            Self(bytes)
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes :=
            M.alloc (|
              Ty.apply
                (Ty.path "array")
                [ M.unevaluated_const (mk_str (| "ubt_key_from_discriminant" |)) ]
                [ Ty.path "u8" ],
              bytes
            |) in
          Value.StructTuple "ubt::key::Stem" [] [] [ M.read (| bytes |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "array")
            [ M.unevaluated_const (mk_str (| "ubt_key_discriminant" |)) ]
            [ Ty.path "u8" ]
        ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_array_expr_u8_for_ubt_key_Stem.
  
  Axiom SubIndex : (Ty.path "ubt::key::SubIndex") = (Ty.path "u8").
  
  (* StructRecord
    {
      name := "TreeKey";
      const_params := [];
      ty_params := [];
      fields := [ ("stem", Ty.path "ubt::key::Stem"); ("subindex", Ty.path "u8") ];
    } *)
  
  Module Impl_core_clone_Clone_for_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::TreeKey" ], self |) in
          M.match_operator (|
            Ty.path "ubt::key::TreeKey",
            Value.DeclaredButUndefined,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.path "ubt::key::TreeKey",
                    Value.DeclaredButUndefined,
                    [ fun γ => ltac:(M.monadic (M.read (| M.deref (| M.read (| self |) |) |))) ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_ubt_key_TreeKey.
  
  Module Impl_core_marker_Copy_for_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_ubt_key_TreeKey.
  
  Module Impl_core_marker_StructuralPartialEq_for_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_ubt_key_TreeKey.
  
  Module Impl_core_cmp_PartialEq_ubt_key_TreeKey_for_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::TreeKey" ], self |) in
          let other :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::TreeKey" ], other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "ubt::key::Stem",
                [],
                [ Ty.path "ubt::key::Stem" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "ubt::key::TreeKey",
                    "stem"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "ubt::key::TreeKey",
                    "stem"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "ubt::key::TreeKey",
                      "subindex"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "ubt::key::TreeKey",
                      "subindex"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "ubt::key::TreeKey" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_ubt_key_TreeKey_for_ubt_key_TreeKey.
  
  Module Impl_core_cmp_Eq_for_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::TreeKey" ], self |) in
          M.match_operator (|
            Ty.tuple [],
            Value.DeclaredButUndefined,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.tuple [],
                    Value.DeclaredButUndefined,
                    [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_ubt_key_TreeKey.
  
  Module Impl_core_hash_Hash_for_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::TreeKey" ], self |) in
          let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "ubt::key::Stem",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "ubt::key::TreeKey",
                          "stem"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              Ty.tuple [],
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "u8",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "ubt::key::TreeKey",
                          "subindex"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_ubt_key_TreeKey.
  
  Module Impl_core_default_Default_for_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.mkStructRecord
            "ubt::key::TreeKey"
            []
            []
            [
              ("stem",
                M.call_closure (|
                  Ty.path "ubt::key::Stem",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "ubt::key::Stem",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("subindex",
                M.call_closure (|
                  Ty.path "u8",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u8",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_ubt_key_TreeKey.
  
  Module Impl_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    (*
        pub const fn new(stem: Stem, subindex: SubIndex) -> Self {
            Self { stem, subindex }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ stem; subindex ] =>
        ltac:(M.monadic
          (let stem := M.alloc (| Ty.path "ubt::key::Stem", stem |) in
          let subindex := M.alloc (| Ty.path "u8", subindex |) in
          Value.mkStructRecord
            "ubt::key::TreeKey"
            []
            []
            [ ("stem", M.read (| stem |)); ("subindex", M.read (| subindex |)) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn from_bytes(bytes: B256) -> Self {
            let mut stem_bytes = [0u8; STEM_LEN];
            stem_bytes.copy_from_slice(&bytes[..STEM_LEN]);
            Self {
                stem: Stem(stem_bytes),
                subindex: bytes[STEM_LEN],
            }
        }
    *)
    Definition from_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes :=
            M.alloc (|
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 32 ]
                [],
              bytes
            |) in
          M.read (|
            let~ stem_bytes :
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 31 ]
                  [ Ty.path "u8" ] :=
              lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 31 |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "copy_from_slice",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 31 ]
                            [ Ty.path "u8" ]
                        ])
                      (Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                    [ M.borrow (| Pointer.Kind.MutRef, stem_bytes |) ]
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                [],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::ops::range::RangeTo")
                                  []
                                  [ Ty.path "usize" ]
                              ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, bytes |);
                              Value.mkStructRecord
                                "core::ops::range::RangeTo"
                                []
                                [ Ty.path "usize" ]
                                [
                                  ("end_",
                                    M.read (|
                                      get_constant (| "ubt::key::STEM_LEN", Ty.path "usize" |)
                                    |))
                                ]
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |) in
            M.alloc (|
              Ty.path "ubt::key::TreeKey",
              Value.mkStructRecord
                "ubt::key::TreeKey"
                []
                []
                [
                  ("stem", Value.StructTuple "ubt::key::Stem" [] [] [ M.read (| stem_bytes |) ]);
                  ("subindex",
                    M.read (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              [],
                            [],
                            [ Ty.path "usize" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, bytes |);
                            M.read (| get_constant (| "ubt::key::STEM_LEN", Ty.path "usize" |) |)
                          ]
                        |)
                      |)
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_bytes :
      M.IsAssociatedFunction.C Self "from_bytes" from_bytes.
    Admitted.
    Global Typeclasses Opaque from_bytes.
    
    (*
        pub fn to_bytes(&self) -> B256 {
            let mut bytes = [0u8; 32];
            bytes[..STEM_LEN].copy_from_slice(&self.stem.0);
            bytes[STEM_LEN] = self.subindex;
            B256::from(bytes)
        }
    *)
    Definition to_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::TreeKey" ], self |) in
          M.read (|
            let~ bytes :
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [ Ty.path "u8" ] :=
              lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 32 |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "copy_from_slice",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::index::IndexMut",
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ],
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ],
                          "index_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, bytes |);
                          Value.mkStructRecord
                            "core::ops::range::RangeTo"
                            []
                            [ Ty.path "usize" ]
                            [
                              ("end_",
                                M.read (|
                                  get_constant (| "ubt::key::STEM_LEN", Ty.path "usize" |)
                                |))
                            ]
                        ]
                      |)
                    |)
                  |);
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 31 ]
                            [ Ty.path "u8" ]
                        ])
                      (Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "ubt::key::TreeKey",
                                "stem"
                              |),
                              "ubt::key::Stem",
                              0
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (|
                  bytes,
                  M.read (| get_constant (| "ubt::key::STEM_LEN", Ty.path "usize" |) |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "ubt::key::TreeKey",
                    "subindex"
                  |)
                |)
              |) in
            M.alloc (|
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 32 ]
                [],
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  [],
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ]
                  ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| bytes |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_bytes : M.IsAssociatedFunction.C Self "to_bytes" to_bytes.
    Admitted.
    Global Typeclasses Opaque to_bytes.
  End Impl_ubt_key_TreeKey.
  
  Module Impl_core_fmt_Debug_for_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(
                f,
                "TreeKey {{ stem: 0x{}, subindex: {} }}",
                hex::encode(self.stem.0),
                self.subindex
            )
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "ubt::key::TreeKey" ], self |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 3 ]
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                          Value.Array
                            [
                              mk_str (| "TreeKey { stem: 0x" |);
                              mk_str (| ", subindex: " |);
                              mk_str (| " }" |)
                            ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 2 ]
                            [ Ty.path "core::fmt::rt::Argument" ],
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "alloc::string::String" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.path "alloc::string::String",
                                          M.call_closure (|
                                            Ty.path "alloc::string::String",
                                            M.get_function (|
                                              "hex::encode",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 31 ]
                                                  [ Ty.path "u8" ]
                                              ]
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_tuple_field (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "ubt::key::TreeKey",
                                                    "stem"
                                                  |),
                                                  "ubt::key::Stem",
                                                  0
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u8" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "ubt::key::TreeKey",
                                          "subindex"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_ubt_key_TreeKey.
  
  Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_32_for_ubt_key_TreeKey.
    Definition Self : Ty.t := Ty.path "ubt::key::TreeKey".
    
    (*
        fn from(bytes: B256) -> Self {
            Self::from_bytes(bytes)
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes :=
            M.alloc (|
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 32 ]
                [],
              bytes
            |) in
          M.call_closure (|
            Ty.path "ubt::key::TreeKey",
            M.get_associated_function (| Ty.path "ubt::key::TreeKey", "from_bytes", [], [] |),
            [ M.read (| bytes |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 32 ]
            []
        ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_32_for_ubt_key_TreeKey.
  
  Module Impl_core_convert_From_ubt_key_TreeKey_for_alloy_primitives_bits_fixed_FixedBytes_Usize_32.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
        [ Value.Integer IntegerKind.Usize 32 ]
        [].
    
    (*
        fn from(key: TreeKey) -> Self {
            key.to_bytes()
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ key ] =>
        ltac:(M.monadic
          (let key := M.alloc (| Ty.path "ubt::key::TreeKey", key |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 32 ]
              [],
            M.get_associated_function (| Ty.path "ubt::key::TreeKey", "to_bytes", [], [] |),
            [ M.borrow (| Pointer.Kind.Ref, key |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "ubt::key::TreeKey" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ubt_key_TreeKey_for_alloy_primitives_bits_fixed_FixedBytes_Usize_32.
End key.
