(* Generated by rocq-of-rust *)
Require Import RocqOfRust.RocqOfRust.

Module embedding.
  Definition value_BASIC_DATA_LEAF_KEY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "u8", Value.Integer IntegerKind.U8 0 |))).
  
  Global Instance Instance_IsConstant_value_BASIC_DATA_LEAF_KEY :
    M.IsFunction.C "ubt::embedding::BASIC_DATA_LEAF_KEY" value_BASIC_DATA_LEAF_KEY.
  Admitted.
  Global Typeclasses Opaque value_BASIC_DATA_LEAF_KEY.
  
  Definition value_CODE_HASH_LEAF_KEY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "u8", Value.Integer IntegerKind.U8 1 |))).
  
  Global Instance Instance_IsConstant_value_CODE_HASH_LEAF_KEY :
    M.IsFunction.C "ubt::embedding::CODE_HASH_LEAF_KEY" value_CODE_HASH_LEAF_KEY.
  Admitted.
  Global Typeclasses Opaque value_CODE_HASH_LEAF_KEY.
  
  Definition value_BASIC_DATA_CODE_SIZE_OFFSET
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 5 |))).
  
  Global Instance Instance_IsConstant_value_BASIC_DATA_CODE_SIZE_OFFSET :
    M.IsFunction.C "ubt::embedding::BASIC_DATA_CODE_SIZE_OFFSET" value_BASIC_DATA_CODE_SIZE_OFFSET.
  Admitted.
  Global Typeclasses Opaque value_BASIC_DATA_CODE_SIZE_OFFSET.
  
  Definition value_BASIC_DATA_NONCE_OFFSET
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 8 |))).
  
  Global Instance Instance_IsConstant_value_BASIC_DATA_NONCE_OFFSET :
    M.IsFunction.C "ubt::embedding::BASIC_DATA_NONCE_OFFSET" value_BASIC_DATA_NONCE_OFFSET.
  Admitted.
  Global Typeclasses Opaque value_BASIC_DATA_NONCE_OFFSET.
  
  Definition value_BASIC_DATA_BALANCE_OFFSET
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 16 |))).
  
  Global Instance Instance_IsConstant_value_BASIC_DATA_BALANCE_OFFSET :
    M.IsFunction.C "ubt::embedding::BASIC_DATA_BALANCE_OFFSET" value_BASIC_DATA_BALANCE_OFFSET.
  Admitted.
  Global Typeclasses Opaque value_BASIC_DATA_BALANCE_OFFSET.
  
  Definition value_HEADER_STORAGE_OFFSET
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "u8", Value.Integer IntegerKind.U8 64 |))).
  
  Global Instance Instance_IsConstant_value_HEADER_STORAGE_OFFSET :
    M.IsFunction.C "ubt::embedding::HEADER_STORAGE_OFFSET" value_HEADER_STORAGE_OFFSET.
  Admitted.
  Global Typeclasses Opaque value_HEADER_STORAGE_OFFSET.
  
  Definition value_CODE_OFFSET (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "u8", Value.Integer IntegerKind.U8 128 |))).
  
  Global Instance Instance_IsConstant_value_CODE_OFFSET :
    M.IsFunction.C "ubt::embedding::CODE_OFFSET" value_CODE_OFFSET.
  Admitted.
  Global Typeclasses Opaque value_CODE_OFFSET.
  
  Definition value_STEM_SUBTREE_WIDTH (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 256 |))).
  
  Global Instance Instance_IsConstant_value_STEM_SUBTREE_WIDTH :
    M.IsFunction.C "ubt::embedding::STEM_SUBTREE_WIDTH" value_STEM_SUBTREE_WIDTH.
  Admitted.
  Global Typeclasses Opaque value_STEM_SUBTREE_WIDTH.
  
  Definition value_MAIN_STORAGE_MARKER (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "u8", Value.Integer IntegerKind.U8 1 |))).
  
  Global Instance Instance_IsConstant_value_MAIN_STORAGE_MARKER :
    M.IsFunction.C "ubt::embedding::MAIN_STORAGE_MARKER" value_MAIN_STORAGE_MARKER.
  Admitted.
  Global Typeclasses Opaque value_MAIN_STORAGE_MARKER.
  
  Definition value_ZERO_PREFIX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 12 ] [ Ty.path "u8" ],
        lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 12 |)
      |))).
  
  Global Instance Instance_IsConstant_value_ZERO_PREFIX :
    M.IsFunction.C "ubt::embedding::ZERO_PREFIX" value_ZERO_PREFIX.
  Admitted.
  Global Typeclasses Opaque value_ZERO_PREFIX.
  
  (*
  pub fn get_binary_tree_key(address: &Address, input_key: &[u8; 32]) -> TreeKey {
      let mut hasher = Sha256::new();
      hasher.update(&ZERO_PREFIX);
      hasher.update(address.as_slice());
      hasher.update(&input_key[..31]);
      
      let hash = hasher.finalize();
      let mut stem_bytes = [0u8; STEM_LEN];
      stem_bytes.copy_from_slice(&hash[..STEM_LEN]);
      
      TreeKey::new(Stem::new(stem_bytes), input_key[31])
  }
  *)
  Definition get_binary_tree_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ address; input_key ] =>
      ltac:(M.monadic
        (let address :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
            address
          |) in
        let input_key :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ]
              ],
            input_key
          |) in
        M.read (|
          let~ hasher :
              Ty.apply
                (Ty.path "digest::core_api::wrapper::CoreWrapper")
                []
                [
                  Ty.apply
                    (Ty.path "digest::core_api::ct_variable::CtVariableCoreWrapper")
                    []
                    [
                      Ty.path "sha2::core_api::Sha256VarCore";
                      Ty.apply
                        (Ty.path "typenum::uint::UInt")
                        []
                        [
                          Ty.apply
                            (Ty.path "typenum::uint::UInt")
                            []
                            [
                              Ty.apply
                                (Ty.path "typenum::uint::UInt")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "typenum::uint::UInt")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "typenum::uint::UInt")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "typenum::uint::UInt")
                                            []
                                            [
                                              Ty.path "typenum::uint::UTerm";
                                              Ty.path "typenum::bit::B1"
                                            ];
                                          Ty.path "typenum::bit::B0"
                                        ];
                                      Ty.path "typenum::bit::B0"
                                    ];
                                  Ty.path "typenum::bit::B0"
                                ];
                              Ty.path "typenum::bit::B0"
                            ];
                          Ty.path "typenum::bit::B0"
                        ];
                      Ty.path "sha2::OidSha256"
                    ]
                ] :=
            M.call_closure (|
              Ty.apply
                (Ty.path "digest::core_api::wrapper::CoreWrapper")
                []
                [
                  Ty.apply
                    (Ty.path "digest::core_api::ct_variable::CtVariableCoreWrapper")
                    []
                    [
                      Ty.path "sha2::core_api::Sha256VarCore";
                      Ty.apply
                        (Ty.path "typenum::uint::UInt")
                        []
                        [
                          Ty.apply
                            (Ty.path "typenum::uint::UInt")
                            []
                            [
                              Ty.apply
                                (Ty.path "typenum::uint::UInt")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "typenum::uint::UInt")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "typenum::uint::UInt")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "typenum::uint::UInt")
                                            []
                                            [
                                              Ty.path "typenum::uint::UTerm";
                                              Ty.path "typenum::bit::B1"
                                            ];
                                          Ty.path "typenum::bit::B0"
                                        ];
                                      Ty.path "typenum::bit::B0"
                                    ];
                                  Ty.path "typenum::bit::B0"
                                ];
                              Ty.path "typenum::bit::B0"
                            ];
                          Ty.path "typenum::bit::B0"
                        ];
                      Ty.path "sha2::OidSha256"
                    ]
                ],
              M.get_trait_method (|
                "digest::digest::Digest",
                Ty.apply
                  (Ty.path "digest::core_api::wrapper::CoreWrapper")
                  []
                  [
                    Ty.apply
                      (Ty.path "digest::core_api::ct_variable::CtVariableCoreWrapper")
                      []
                      [
                        Ty.path "sha2::core_api::Sha256VarCore";
                        Ty.apply
                          (Ty.path "typenum::uint::UInt")
                          []
                          [
                            Ty.apply
                              (Ty.path "typenum::uint::UInt")
                              []
                              [
                                Ty.apply
                                  (Ty.path "typenum::uint::UInt")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "typenum::uint::UInt")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "typenum::uint::UInt")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "typenum::uint::UInt")
                                              []
                                              [
                                                Ty.path "typenum::uint::UTerm";
                                                Ty.path "typenum::bit::B1"
                                              ];
                                            Ty.path "typenum::bit::B0"
                                          ];
                                        Ty.path "typenum::bit::B0"
                                      ];
                                    Ty.path "typenum::bit::B0"
                                  ];
                                Ty.path "typenum::bit::B0"
                              ];
                            Ty.path "typenum::bit::B0"
                          ];
                        Ty.path "sha2::OidSha256"
                      ]
                  ],
                [],
                [],
                "new",
                [],
                []
              |),
              []
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "digest::digest::Digest",
                Ty.apply
                  (Ty.path "digest::core_api::wrapper::CoreWrapper")
                  []
                  [
                    Ty.apply
                      (Ty.path "digest::core_api::ct_variable::CtVariableCoreWrapper")
                      []
                      [
                        Ty.path "sha2::core_api::Sha256VarCore";
                        Ty.apply
                          (Ty.path "typenum::uint::UInt")
                          []
                          [
                            Ty.apply
                              (Ty.path "typenum::uint::UInt")
                              []
                              [
                                Ty.apply
                                  (Ty.path "typenum::uint::UInt")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "typenum::uint::UInt")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "typenum::uint::UInt")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "typenum::uint::UInt")
                                              []
                                              [
                                                Ty.path "typenum::uint::UTerm";
                                                Ty.path "typenum::bit::B1"
                                              ];
                                            Ty.path "typenum::bit::B0"
                                          ];
                                        Ty.path "typenum::bit::B0"
                                      ];
                                    Ty.path "typenum::bit::B0"
                                  ];
                                Ty.path "typenum::bit::B0"
                              ];
                            Ty.path "typenum::bit::B0"
                          ];
                        Ty.path "sha2::OidSha256"
                      ]
                  ],
                [],
                [],
                "update",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 12 ]
                        [ Ty.path "u8" ]
                    ]
                ]
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, hasher |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  get_constant (|
                    "ubt::embedding::ZERO_PREFIX",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 12 ]
                      [ Ty.path "u8" ]
                  |)
                |)
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "digest::digest::Digest",
                Ty.apply
                  (Ty.path "digest::core_api::wrapper::CoreWrapper")
                  []
                  [
                    Ty.apply
                      (Ty.path "digest::core_api::ct_variable::CtVariableCoreWrapper")
                      []
                      [
                        Ty.path "sha2::core_api::Sha256VarCore";
                        Ty.apply
                          (Ty.path "typenum::uint::UInt")
                          []
                          [
                            Ty.apply
                              (Ty.path "typenum::uint::UInt")
                              []
                              [
                                Ty.apply
                                  (Ty.path "typenum::uint::UInt")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "typenum::uint::UInt")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "typenum::uint::UInt")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "typenum::uint::UInt")
                                              []
                                              [
                                                Ty.path "typenum::uint::UTerm";
                                                Ty.path "typenum::bit::B1"
                                              ];
                                            Ty.path "typenum::bit::B0"
                                          ];
                                        Ty.path "typenum::bit::B0"
                                      ];
                                    Ty.path "typenum::bit::B0"
                                  ];
                                Ty.path "typenum::bit::B0"
                              ];
                            Ty.path "typenum::bit::B0"
                          ];
                        Ty.path "sha2::OidSha256"
                      ]
                  ],
                [],
                [],
                "update",
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, hasher |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    "as_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 20 ]
                                []
                            ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.path "alloy_primitives::bits::address::Address",
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "digest::digest::Digest",
                Ty.apply
                  (Ty.path "digest::core_api::wrapper::CoreWrapper")
                  []
                  [
                    Ty.apply
                      (Ty.path "digest::core_api::ct_variable::CtVariableCoreWrapper")
                      []
                      [
                        Ty.path "sha2::core_api::Sha256VarCore";
                        Ty.apply
                          (Ty.path "typenum::uint::UInt")
                          []
                          [
                            Ty.apply
                              (Ty.path "typenum::uint::UInt")
                              []
                              [
                                Ty.apply
                                  (Ty.path "typenum::uint::UInt")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "typenum::uint::UInt")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "typenum::uint::UInt")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "typenum::uint::UInt")
                                              []
                                              [
                                                Ty.path "typenum::uint::UTerm";
                                                Ty.path "typenum::bit::B1"
                                              ];
                                            Ty.path "typenum::bit::B0"
                                          ];
                                        Ty.path "typenum::bit::B0"
                                      ];
                                    Ty.path "typenum::bit::B0"
                                  ];
                                Ty.path "typenum::bit::B0"
                              ];
                            Ty.path "typenum::bit::B0"
                          ];
                        Ty.path "sha2::OidSha256"
                      ]
                  ],
                [],
                [],
                "update",
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, hasher |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::ops::index::Index",
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 32 ]
                          [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ],
                        "index",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| input_key |) |) |);
                        Value.mkStructRecord
                          "core::ops::range::RangeTo"
                          []
                          [ Ty.path "usize" ]
                          [ ("end_", Value.Integer IntegerKind.Usize 31) ]
                      ]
                    |)
                  |)
                |)
              ]
            |) in
          let~ hash :
              Ty.apply
                (Ty.path "generic_array::GenericArray")
                []
                [
                  Ty.path "u8";
                  Ty.apply
                    (Ty.path "typenum::uint::UInt")
                    []
                    [
                      Ty.apply
                        (Ty.path "typenum::uint::UInt")
                        []
                        [
                          Ty.apply
                            (Ty.path "typenum::uint::UInt")
                            []
                            [
                              Ty.apply
                                (Ty.path "typenum::uint::UInt")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "typenum::uint::UInt")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "typenum::uint::UInt")
                                        []
                                        [ Ty.path "typenum::uint::UTerm"; Ty.path "typenum::bit::B1"
                                        ];
                                      Ty.path "typenum::bit::B0"
                                    ];
                                  Ty.path "typenum::bit::B0"
                                ];
                              Ty.path "typenum::bit::B0"
                            ];
                          Ty.path "typenum::bit::B0"
                        ];
                      Ty.path "typenum::bit::B0"
                    ]
                ] :=
            M.call_closure (|
              Ty.apply
                (Ty.path "generic_array::GenericArray")
                []
                [
                  Ty.path "u8";
                  Ty.apply
                    (Ty.path "typenum::uint::UInt")
                    []
                    [
                      Ty.apply
                        (Ty.path "typenum::uint::UInt")
                        []
                        [
                          Ty.apply
                            (Ty.path "typenum::uint::UInt")
                            []
                            [
                              Ty.apply
                                (Ty.path "typenum::uint::UInt")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "typenum::uint::UInt")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "typenum::uint::UInt")
                                        []
                                        [ Ty.path "typenum::uint::UTerm"; Ty.path "typenum::bit::B1"
                                        ];
                                      Ty.path "typenum::bit::B0"
                                    ];
                                  Ty.path "typenum::bit::B0"
                                ];
                              Ty.path "typenum::bit::B0"
                            ];
                          Ty.path "typenum::bit::B0"
                        ];
                      Ty.path "typenum::bit::B0"
                    ]
                ],
              M.get_trait_method (|
                "digest::digest::Digest",
                Ty.apply
                  (Ty.path "digest::core_api::wrapper::CoreWrapper")
                  []
                  [
                    Ty.apply
                      (Ty.path "digest::core_api::ct_variable::CtVariableCoreWrapper")
                      []
                      [
                        Ty.path "sha2::core_api::Sha256VarCore";
                        Ty.apply
                          (Ty.path "typenum::uint::UInt")
                          []
                          [
                            Ty.apply
                              (Ty.path "typenum::uint::UInt")
                              []
                              [
                                Ty.apply
                                  (Ty.path "typenum::uint::UInt")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "typenum::uint::UInt")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "typenum::uint::UInt")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "typenum::uint::UInt")
                                              []
                                              [
                                                Ty.path "typenum::uint::UTerm";
                                                Ty.path "typenum::bit::B1"
                                              ];
                                            Ty.path "typenum::bit::B0"
                                          ];
                                        Ty.path "typenum::bit::B0"
                                      ];
                                    Ty.path "typenum::bit::B0"
                                  ];
                                Ty.path "typenum::bit::B0"
                              ];
                            Ty.path "typenum::bit::B0"
                          ];
                        Ty.path "sha2::OidSha256"
                      ]
                  ],
                [],
                [],
                "finalize",
                [],
                []
              |),
              [ M.read (| hasher |) ]
            |) in
          let~ stem_bytes :
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 31 ] [ Ty.path "u8" ] :=
            lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 31 |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                "copy_from_slice",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 31 ]
                          [ Ty.path "u8" ]
                      ])
                    (Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                  [ M.borrow (| Pointer.Kind.MutRef, stem_bytes |) ]
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                            [],
                            [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ]
                            ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "generic_array::GenericArray")
                                      []
                                      [
                                        Ty.path "u8";
                                        Ty.apply
                                          (Ty.path "typenum::uint::UInt")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "typenum::uint::UInt")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "typenum::uint::UInt")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "typenum::uint::UInt")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "typenum::uint::UInt")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "typenum::uint::UInt")
                                                              []
                                                              [
                                                                Ty.path "typenum::uint::UTerm";
                                                                Ty.path "typenum::bit::B1"
                                                              ];
                                                            Ty.path "typenum::bit::B0"
                                                          ];
                                                        Ty.path "typenum::bit::B0"
                                                      ];
                                                    Ty.path "typenum::bit::B0"
                                                  ];
                                                Ty.path "typenum::bit::B0"
                                              ];
                                            Ty.path "typenum::bit::B0"
                                          ]
                                      ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, hash |) ]
                                |)
                              |)
                            |);
                            Value.mkStructRecord
                              "core::ops::range::RangeTo"
                              []
                              [ Ty.path "usize" ]
                              [
                                ("end_",
                                  M.read (|
                                    get_constant (| "ubt::key::STEM_LEN", Ty.path "usize" |)
                                  |))
                              ]
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |) in
          M.alloc (|
            Ty.path "ubt::key::TreeKey",
            M.call_closure (|
              Ty.path "ubt::key::TreeKey",
              M.get_associated_function (| Ty.path "ubt::key::TreeKey", "new", [], [] |),
              [
                M.call_closure (|
                  Ty.path "ubt::key::Stem",
                  M.get_associated_function (| Ty.path "ubt::key::Stem", "new", [], [] |),
                  [ M.read (| stem_bytes |) ]
                |);
                M.read (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| input_key |) |),
                    Value.Integer IntegerKind.Usize 31
                  |)
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_get_binary_tree_key :
    M.IsFunction.C "ubt::embedding::get_binary_tree_key" get_binary_tree_key.
  Admitted.
  Global Typeclasses Opaque get_binary_tree_key.
  
  (*
  pub fn get_basic_data_key(address: &Address) -> TreeKey {
      let mut k = [0u8; 32];
      k[31] = BASIC_DATA_LEAF_KEY;
      get_binary_tree_key(address, &k)
  }
  *)
  Definition get_basic_data_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ address ] =>
      ltac:(M.monadic
        (let address :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
            address
          |) in
        M.read (|
          let~ k :
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ] :=
            lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 32 |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| k, Value.Integer IntegerKind.Usize 31 |),
              M.read (| get_constant (| "ubt::embedding::BASIC_DATA_LEAF_KEY", Ty.path "u8" |) |)
            |) in
          M.alloc (|
            Ty.path "ubt::key::TreeKey",
            M.call_closure (|
              Ty.path "ubt::key::TreeKey",
              M.get_function (| "ubt::embedding::get_binary_tree_key", [], [] |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, k |) |) |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_get_basic_data_key :
    M.IsFunction.C "ubt::embedding::get_basic_data_key" get_basic_data_key.
  Admitted.
  Global Typeclasses Opaque get_basic_data_key.
  
  (*
  pub fn get_code_hash_key(address: &Address) -> TreeKey {
      let mut k = [0u8; 32];
      k[31] = CODE_HASH_LEAF_KEY;
      get_binary_tree_key(address, &k)
  }
  *)
  Definition get_code_hash_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ address ] =>
      ltac:(M.monadic
        (let address :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
            address
          |) in
        M.read (|
          let~ k :
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ] :=
            lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 32 |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| k, Value.Integer IntegerKind.Usize 31 |),
              M.read (| get_constant (| "ubt::embedding::CODE_HASH_LEAF_KEY", Ty.path "u8" |) |)
            |) in
          M.alloc (|
            Ty.path "ubt::key::TreeKey",
            M.call_closure (|
              Ty.path "ubt::key::TreeKey",
              M.get_function (| "ubt::embedding::get_binary_tree_key", [], [] |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, k |) |) |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_get_code_hash_key :
    M.IsFunction.C "ubt::embedding::get_code_hash_key" get_code_hash_key.
  Admitted.
  Global Typeclasses Opaque get_code_hash_key.
  
  (*
  pub fn get_storage_slot_key(address: &Address, slot: &[u8; 32]) -> TreeKey {
      let mut k = [0u8; 32];
      
      // Check if key belongs to account header (first 31 bytes zero, last byte < 64)
      let is_header_slot = slot[..31].iter().all(|&b| b == 0) && slot[31] < 64;
      
      if is_header_slot {
          // Header storage: subindex = 64 + slot
          k[31] = HEADER_STORAGE_OFFSET + slot[31];
      } else {
          // Main storage: set marker byte and copy slot
          k[0] = MAIN_STORAGE_MARKER; // 1 << 248
          k[1..32].copy_from_slice(&slot[..31]);
          k[31] = slot[31];
      }
      
      get_binary_tree_key(address, &k)
  }
  *)
  Definition get_storage_slot_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ address; slot ] =>
      ltac:(M.monadic
        (let address :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
            address
          |) in
        let slot :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ]
              ],
            slot
          |) in
        M.read (|
          let~ k :
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ] :=
            lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 32 |) in
          let~ is_header_slot : Ty.path "bool" :=
            LogicalOp.and (|
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
                  [],
                  [],
                  "all",
                  [],
                  [ Ty.function [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ] (Ty.path "bool") ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.alloc (|
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "iter",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 32 ]
                                    [ Ty.path "u8" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeTo")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slot |) |) |);
                                  Value.mkStructRecord
                                    "core::ops::range::RangeTo"
                                    []
                                    [ Ty.path "usize" ]
                                    [ ("end_", Value.Integer IntegerKind.Usize 31) ]
                                ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.path "bool",
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u8" ], α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.deref (| M.read (| γ |) |) in
                                    let b := M.copy (| Ty.path "u8", γ |) in
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [ M.read (| b |); Value.Integer IntegerKind.U8 0 ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  BinOp.lt,
                  [
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| slot |) |),
                        Value.Integer IntegerKind.Usize 31
                      |)
                    |);
                    Value.Integer IntegerKind.U8 64
                  ]
                |)))
            |) in
          let~ _ : Ty.tuple [] :=
            M.match_operator (|
              Ty.tuple [],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use is_header_slot in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.read (|
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_array_field (| k, Value.Integer IntegerKind.Usize 31 |),
                          M.call_closure (|
                            Ty.path "u8",
                            BinOp.Wrap.add,
                            [
                              M.read (|
                                get_constant (|
                                  "ubt::embedding::HEADER_STORAGE_OFFSET",
                                  Ty.path "u8"
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| slot |) |),
                                  Value.Integer IntegerKind.Usize 31
                                |)
                              |)
                            ]
                          |)
                        |) in
                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.read (|
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_array_field (| k, Value.Integer IntegerKind.Usize 0 |),
                          M.read (|
                            get_constant (| "ubt::embedding::MAIN_STORAGE_MARKER", Ty.path "u8" |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                            "copy_from_slice",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  M.get_trait_method (|
                                    "core::ops::index::IndexMut",
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 32 ]
                                      [ Ty.path "u8" ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "usize" ]
                                    ],
                                    "index_mut",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.MutRef, k |);
                                    Value.mkStructRecord
                                      "core::ops::range::Range"
                                      []
                                      [ Ty.path "usize" ]
                                      [
                                        ("start", Value.Integer IntegerKind.Usize 1);
                                        ("end_", Value.Integer IntegerKind.Usize 32)
                                      ]
                                  ]
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 32 ]
                                          [ Ty.path "u8" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeTo")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| slot |) |)
                                        |);
                                        Value.mkStructRecord
                                          "core::ops::range::RangeTo"
                                          []
                                          [ Ty.path "usize" ]
                                          [ ("end_", Value.Integer IntegerKind.Usize 31) ]
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.write (|
                          M.SubPointer.get_array_field (| k, Value.Integer IntegerKind.Usize 31 |),
                          M.read (|
                            M.SubPointer.get_array_field (|
                              M.deref (| M.read (| slot |) |),
                              Value.Integer IntegerKind.Usize 31
                            |)
                          |)
                        |) in
                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                    |)))
              ]
            |) in
          M.alloc (|
            Ty.path "ubt::key::TreeKey",
            M.call_closure (|
              Ty.path "ubt::key::TreeKey",
              M.get_function (| "ubt::embedding::get_binary_tree_key", [], [] |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, k |) |) |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_get_storage_slot_key :
    M.IsFunction.C "ubt::embedding::get_storage_slot_key" get_storage_slot_key.
  Admitted.
  Global Typeclasses Opaque get_storage_slot_key.
  
  (*
  pub fn get_storage_slot_key_u256(address: &Address, slot: U256) -> TreeKey {
      get_storage_slot_key(address, &slot.to_be_bytes::<32>())
  }
  *)
  Definition get_storage_slot_key_u256 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ address; slot ] =>
      ltac:(M.monadic
        (let address :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
            address
          |) in
        let slot :=
          M.alloc (|
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
              [],
            slot
          |) in
        M.call_closure (|
          Ty.path "ubt::key::TreeKey",
          M.get_function (| "ubt::embedding::get_storage_slot_key", [], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ],
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                          [],
                        "to_be_bytes",
                        [ Value.Integer IntegerKind.Usize 32 ],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, slot |) ]
                    |)
                  |)
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_get_storage_slot_key_u256 :
    M.IsFunction.C "ubt::embedding::get_storage_slot_key_u256" get_storage_slot_key_u256.
  Admitted.
  Global Typeclasses Opaque get_storage_slot_key_u256.
  
  (*
  pub fn get_code_chunk_key(address: &Address, chunk_number: u64) -> TreeKey {
      let chunk_offset = 128u64 + chunk_number;
      let mut k = [0u8; 32];
      
      // Store chunk offset as little-endian in bytes 24-31 per geth
      k[24..32].copy_from_slice(&chunk_offset.to_le_bytes());
      
      get_binary_tree_key(address, &k)
  }
  *)
  Definition get_code_chunk_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ address; chunk_number ] =>
      ltac:(M.monadic
        (let address :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
            address
          |) in
        let chunk_number := M.alloc (| Ty.path "u64", chunk_number |) in
        M.read (|
          let~ chunk_offset : Ty.path "u64" :=
            M.call_closure (|
              Ty.path "u64",
              BinOp.Wrap.add,
              [ Value.Integer IntegerKind.U64 128; M.read (| chunk_number |) ]
            |) in
          let~ k :
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ] :=
            lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 32 |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                "copy_from_slice",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::ops::index::IndexMut",
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 32 ]
                          [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                        "index_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, k |);
                        Value.mkStructRecord
                          "core::ops::range::Range"
                          []
                          [ Ty.path "usize" ]
                          [
                            ("start", Value.Integer IntegerKind.Usize 24);
                            ("end_", Value.Integer IntegerKind.Usize 32)
                          ]
                      ]
                    |)
                  |)
                |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 8 ]
                          [ Ty.path "u8" ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 8 ]
                              [ Ty.path "u8" ],
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 8 ]
                                [ Ty.path "u8" ],
                              M.get_associated_function (| Ty.path "u64", "to_le_bytes", [], [] |),
                              [ M.read (| chunk_offset |) ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |) in
          M.alloc (|
            Ty.path "ubt::key::TreeKey",
            M.call_closure (|
              Ty.path "ubt::key::TreeKey",
              M.get_function (| "ubt::embedding::get_binary_tree_key", [], [] |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, k |) |) |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_get_code_chunk_key :
    M.IsFunction.C "ubt::embedding::get_code_chunk_key" get_code_chunk_key.
  Admitted.
  Global Typeclasses Opaque get_code_chunk_key.
  
  (* StructRecord
    {
      name := "BasicDataLeaf";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("version", Ty.path "u8");
          ("code_size", Ty.path "u32");
          ("nonce", Ty.path "u64");
          ("balance", Ty.path "u128")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_ubt_embedding_BasicDataLeaf.
    Definition Self : Ty.t := Ty.path "ubt::embedding::BasicDataLeaf".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::BasicDataLeaf" ],
              self
            |) in
          M.match_operator (|
            Ty.path "ubt::embedding::BasicDataLeaf",
            Value.DeclaredButUndefined,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.path "ubt::embedding::BasicDataLeaf",
                    Value.DeclaredButUndefined,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.path "ubt::embedding::BasicDataLeaf",
                            Value.DeclaredButUndefined,
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Ty.path "ubt::embedding::BasicDataLeaf",
                                    Value.DeclaredButUndefined,
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.read (| M.deref (| M.read (| self |) |) |)))
                                    ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_ubt_embedding_BasicDataLeaf.
  
  Module Impl_core_marker_Copy_for_ubt_embedding_BasicDataLeaf.
    Definition Self : Ty.t := Ty.path "ubt::embedding::BasicDataLeaf".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_ubt_embedding_BasicDataLeaf.
  
  Module Impl_core_fmt_Debug_for_ubt_embedding_BasicDataLeaf.
    Definition Self : Ty.t := Ty.path "ubt::embedding::BasicDataLeaf".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::BasicDataLeaf" ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field4_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "BasicDataLeaf" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "version" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply (Ty.path "&") [] [ Ty.path "u8" ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "ubt::embedding::BasicDataLeaf",
                          "version"
                        |)
                      |)
                    |)
                  |)
                ]
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "code_size" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "ubt::embedding::BasicDataLeaf",
                          "code_size"
                        |)
                      |)
                    |)
                  |)
                ]
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "nonce" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply (Ty.path "&") [] [ Ty.path "u64" ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "ubt::embedding::BasicDataLeaf",
                          "nonce"
                        |)
                      |)
                    |)
                  |)
                ]
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "balance" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "u128" ] ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "u128" ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "ubt::embedding::BasicDataLeaf",
                              "balance"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_ubt_embedding_BasicDataLeaf.
  
  Module Impl_core_default_Default_for_ubt_embedding_BasicDataLeaf.
    Definition Self : Ty.t := Ty.path "ubt::embedding::BasicDataLeaf".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.mkStructRecord
            "ubt::embedding::BasicDataLeaf"
            []
            []
            [
              ("version",
                M.call_closure (|
                  Ty.path "u8",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u8",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("code_size",
                M.call_closure (|
                  Ty.path "u32",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u32",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("nonce",
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u64",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("balance",
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u128",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_ubt_embedding_BasicDataLeaf.
  
  Module Impl_core_marker_StructuralPartialEq_for_ubt_embedding_BasicDataLeaf.
    Definition Self : Ty.t := Ty.path "ubt::embedding::BasicDataLeaf".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_ubt_embedding_BasicDataLeaf.
  
  Module Impl_core_cmp_PartialEq_ubt_embedding_BasicDataLeaf_for_ubt_embedding_BasicDataLeaf.
    Definition Self : Ty.t := Ty.path "ubt::embedding::BasicDataLeaf".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::BasicDataLeaf" ],
              self
            |) in
          let other :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::BasicDataLeaf" ],
              other
            |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "ubt::embedding::BasicDataLeaf",
                        "version"
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "ubt::embedding::BasicDataLeaf",
                        "version"
                      |)
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "ubt::embedding::BasicDataLeaf",
                          "code_size"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "ubt::embedding::BasicDataLeaf",
                          "code_size"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "ubt::embedding::BasicDataLeaf",
                        "nonce"
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "ubt::embedding::BasicDataLeaf",
                        "nonce"
                      |)
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "ubt::embedding::BasicDataLeaf",
                      "balance"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "ubt::embedding::BasicDataLeaf",
                      "balance"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "ubt::embedding::BasicDataLeaf" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_ubt_embedding_BasicDataLeaf_for_ubt_embedding_BasicDataLeaf.
  
  Module Impl_core_cmp_Eq_for_ubt_embedding_BasicDataLeaf.
    Definition Self : Ty.t := Ty.path "ubt::embedding::BasicDataLeaf".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::BasicDataLeaf" ],
              self
            |) in
          M.match_operator (|
            Ty.tuple [],
            Value.DeclaredButUndefined,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.tuple [],
                    Value.DeclaredButUndefined,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.tuple [],
                            Value.DeclaredButUndefined,
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Ty.tuple [],
                                    Value.DeclaredButUndefined,
                                    [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_ubt_embedding_BasicDataLeaf.
  
  Module Impl_ubt_embedding_BasicDataLeaf.
    Definition Self : Ty.t := Ty.path "ubt::embedding::BasicDataLeaf".
    
    (*
        pub const fn new(nonce: u64, balance: u128, code_size: u32) -> Self {
            Self {
                version: 0,
                code_size,
                nonce,
                balance,
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ nonce; balance; code_size ] =>
        ltac:(M.monadic
          (let nonce := M.alloc (| Ty.path "u64", nonce |) in
          let balance := M.alloc (| Ty.path "u128", balance |) in
          let code_size := M.alloc (| Ty.path "u32", code_size |) in
          Value.mkStructRecord
            "ubt::embedding::BasicDataLeaf"
            []
            []
            [
              ("version", Value.Integer IntegerKind.U8 0);
              ("code_size", M.read (| code_size |));
              ("nonce", M.read (| nonce |));
              ("balance", M.read (| balance |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn encode(&self) -> B256 {
            let mut bytes = [0u8; 32];
            bytes[0] = self.version;
            // bytes[1..5] = reserved
            bytes[5..8].copy_from_slice(&self.code_size.to_be_bytes()[1..4]); // 3 bytes
            bytes[8..16].copy_from_slice(&self.nonce.to_be_bytes());
            bytes[16..32].copy_from_slice(&self.balance.to_be_bytes());
            B256::from(bytes)
        }
    *)
    Definition encode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::BasicDataLeaf" ],
              self
            |) in
          M.read (|
            let~ bytes :
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [ Ty.path "u8" ] :=
              lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 32 |) in
            let~ _ : Ty.tuple [] :=
              M.write (|
                M.SubPointer.get_array_field (| bytes, Value.Integer IntegerKind.Usize 0 |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "ubt::embedding::BasicDataLeaf",
                    "version"
                  |)
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "copy_from_slice",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::index::IndexMut",
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ],
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                          "index_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, bytes |);
                          Value.mkStructRecord
                            "core::ops::range::Range"
                            []
                            [ Ty.path "usize" ]
                            [
                              ("start", Value.Integer IntegerKind.Usize 5);
                              ("end_", Value.Integer IntegerKind.Usize 8)
                            ]
                        ]
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 4 ]
                                [ Ty.path "u8" ],
                              [],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]
                              ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 4 ]
                                    [ Ty.path "u8" ],
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 4 ]
                                      [ Ty.path "u8" ],
                                    M.get_associated_function (|
                                      Ty.path "u32",
                                      "to_be_bytes",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "ubt::embedding::BasicDataLeaf",
                                          "code_size"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |);
                              Value.mkStructRecord
                                "core::ops::range::Range"
                                []
                                [ Ty.path "usize" ]
                                [
                                  ("start", Value.Integer IntegerKind.Usize 1);
                                  ("end_", Value.Integer IntegerKind.Usize 4)
                                ]
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "copy_from_slice",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::index::IndexMut",
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ],
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                          "index_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, bytes |);
                          Value.mkStructRecord
                            "core::ops::range::Range"
                            []
                            [ Ty.path "usize" ]
                            [
                              ("start", Value.Integer IntegerKind.Usize 8);
                              ("end_", Value.Integer IntegerKind.Usize 16)
                            ]
                        ]
                      |)
                    |)
                  |);
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 8 ]
                            [ Ty.path "u8" ]
                        ])
                      (Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 8 ]
                                [ Ty.path "u8" ],
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 8 ]
                                  [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.path "u64",
                                  "to_be_bytes",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "ubt::embedding::BasicDataLeaf",
                                      "nonce"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "copy_from_slice",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::index::IndexMut",
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ],
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                          "index_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, bytes |);
                          Value.mkStructRecord
                            "core::ops::range::Range"
                            []
                            [ Ty.path "usize" ]
                            [
                              ("start", Value.Integer IntegerKind.Usize 16);
                              ("end_", Value.Integer IntegerKind.Usize 32)
                            ]
                        ]
                      |)
                    |)
                  |);
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 16 ]
                            [ Ty.path "u8" ]
                        ])
                      (Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 16 ]
                                [ Ty.path "u8" ],
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 16 ]
                                  [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.path "u128",
                                  "to_be_bytes",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "ubt::embedding::BasicDataLeaf",
                                      "balance"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            M.alloc (|
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 32 ]
                [],
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  [],
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ]
                  ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| bytes |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_encode : M.IsAssociatedFunction.C Self "encode" encode.
    Admitted.
    Global Typeclasses Opaque encode.
    
    (*
        pub fn decode(value: B256) -> Self {
            let bytes = value.as_slice();
            
            let mut code_size_bytes = [0u8; 4];
            code_size_bytes[1..4].copy_from_slice(&bytes[5..8]);
            
            let mut nonce_bytes = [0u8; 8];
            nonce_bytes.copy_from_slice(&bytes[8..16]);
            
            let mut balance_bytes = [0u8; 16];
            balance_bytes.copy_from_slice(&bytes[16..32]);
            
            Self {
                version: bytes[0],
                code_size: u32::from_be_bytes(code_size_bytes),
                nonce: u64::from_be_bytes(nonce_bytes),
                balance: u128::from_be_bytes(balance_bytes),
            }
        }
    *)
    Definition decode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value :=
            M.alloc (|
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 32 ]
                [],
              value
            |) in
          M.read (|
            let~ bytes :
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  "as_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, value |) ]
              |) in
            let~ code_size_bytes :
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ Ty.path "u8" ] :=
              lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 4 |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "copy_from_slice",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::index::IndexMut",
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 4 ]
                            [ Ty.path "u8" ],
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                          "index_mut",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, code_size_bytes |);
                          Value.mkStructRecord
                            "core::ops::range::Range"
                            []
                            [ Ty.path "usize" ]
                            [
                              ("start", Value.Integer IntegerKind.Usize 1);
                              ("end_", Value.Integer IntegerKind.Usize 4)
                            ]
                        ]
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              [],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]
                              ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |);
                              Value.mkStructRecord
                                "core::ops::range::Range"
                                []
                                [ Ty.path "usize" ]
                                [
                                  ("start", Value.Integer IntegerKind.Usize 5);
                                  ("end_", Value.Integer IntegerKind.Usize 8)
                                ]
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |) in
            let~ nonce_bytes :
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ] :=
              lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 8 |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "copy_from_slice",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 8 ]
                            [ Ty.path "u8" ]
                        ])
                      (Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                    [ M.borrow (| Pointer.Kind.MutRef, nonce_bytes |) ]
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              [],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]
                              ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |);
                              Value.mkStructRecord
                                "core::ops::range::Range"
                                []
                                [ Ty.path "usize" ]
                                [
                                  ("start", Value.Integer IntegerKind.Usize 8);
                                  ("end_", Value.Integer IntegerKind.Usize 16)
                                ]
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |) in
            let~ balance_bytes :
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 16 ]
                  [ Ty.path "u8" ] :=
              lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 16 |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "copy_from_slice",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 16 ]
                            [ Ty.path "u8" ]
                        ])
                      (Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                    [ M.borrow (| Pointer.Kind.MutRef, balance_bytes |) ]
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              [],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]
                              ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |);
                              Value.mkStructRecord
                                "core::ops::range::Range"
                                []
                                [ Ty.path "usize" ]
                                [
                                  ("start", Value.Integer IntegerKind.Usize 16);
                                  ("end_", Value.Integer IntegerKind.Usize 32)
                                ]
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |) in
            M.alloc (|
              Ty.path "ubt::embedding::BasicDataLeaf",
              Value.mkStructRecord
                "ubt::embedding::BasicDataLeaf"
                []
                []
                [
                  ("version",
                    M.read (|
                      M.SubPointer.get_array_field (|
                        M.deref (| M.read (| bytes |) |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |));
                  ("code_size",
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (| Ty.path "u32", "from_be_bytes", [], [] |),
                      [ M.read (| code_size_bytes |) ]
                    |));
                  ("nonce",
                    M.call_closure (|
                      Ty.path "u64",
                      M.get_associated_function (| Ty.path "u64", "from_be_bytes", [], [] |),
                      [ M.read (| nonce_bytes |) ]
                    |));
                  ("balance",
                    M.call_closure (|
                      Ty.path "u128",
                      M.get_associated_function (| Ty.path "u128", "from_be_bytes", [], [] |),
                      [ M.read (| balance_bytes |) ]
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_decode : M.IsAssociatedFunction.C Self "decode" decode.
    Admitted.
    Global Typeclasses Opaque decode.
  End Impl_ubt_embedding_BasicDataLeaf.
  
  (* StructRecord
    {
      name := "AccountStem";
      const_params := [];
      ty_params := [];
      fields := [ ("address", Ty.path "alloy_primitives::bits::address::Address") ];
    } *)
  
  Module Impl_ubt_embedding_AccountStem.
    Definition Self : Ty.t := Ty.path "ubt::embedding::AccountStem".
    
    (*
        pub fn new(address: Address) -> Self {
            Self { address }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ address ] =>
        ltac:(M.monadic
          (let address :=
            M.alloc (| Ty.path "alloy_primitives::bits::address::Address", address |) in
          Value.mkStructRecord
            "ubt::embedding::AccountStem"
            []
            []
            [ ("address", M.read (| address |)) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn basic_data_key(&self) -> TreeKey {
            get_basic_data_key(&self.address)
        }
    *)
    Definition basic_data_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::AccountStem" ],
              self
            |) in
          M.call_closure (|
            Ty.path "ubt::key::TreeKey",
            M.get_function (| "ubt::embedding::get_basic_data_key", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "ubt::embedding::AccountStem",
                      "address"
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_basic_data_key :
      M.IsAssociatedFunction.C Self "basic_data_key" basic_data_key.
    Admitted.
    Global Typeclasses Opaque basic_data_key.
    
    (*
        pub fn code_hash_key(&self) -> TreeKey {
            get_code_hash_key(&self.address)
        }
    *)
    Definition code_hash_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::AccountStem" ],
              self
            |) in
          M.call_closure (|
            Ty.path "ubt::key::TreeKey",
            M.get_function (| "ubt::embedding::get_code_hash_key", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "ubt::embedding::AccountStem",
                      "address"
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_code_hash_key :
      M.IsAssociatedFunction.C Self "code_hash_key" code_hash_key.
    Admitted.
    Global Typeclasses Opaque code_hash_key.
    
    (*
        pub fn storage_key(&self, slot: U256) -> TreeKey {
            get_storage_slot_key_u256(&self.address, slot)
        }
    *)
    Definition storage_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; slot ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::AccountStem" ],
              self
            |) in
          let slot :=
            M.alloc (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              slot
            |) in
          M.call_closure (|
            Ty.path "ubt::key::TreeKey",
            M.get_function (| "ubt::embedding::get_storage_slot_key_u256", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "ubt::embedding::AccountStem",
                      "address"
                    |)
                  |)
                |)
              |);
              M.read (| slot |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_storage_key :
      M.IsAssociatedFunction.C Self "storage_key" storage_key.
    Admitted.
    Global Typeclasses Opaque storage_key.
    
    (*
        pub fn code_chunk_key(&self, chunk_index: u64) -> TreeKey {
            get_code_chunk_key(&self.address, chunk_index)
        }
    *)
    Definition code_chunk_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; chunk_index ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "ubt::embedding::AccountStem" ],
              self
            |) in
          let chunk_index := M.alloc (| Ty.path "u64", chunk_index |) in
          M.call_closure (|
            Ty.path "ubt::key::TreeKey",
            M.get_function (| "ubt::embedding::get_code_chunk_key", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "ubt::embedding::AccountStem",
                      "address"
                    |)
                  |)
                |)
              |);
              M.read (| chunk_index |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_code_chunk_key :
      M.IsAssociatedFunction.C Self "code_chunk_key" code_chunk_key.
    Admitted.
    Global Typeclasses Opaque code_chunk_key.
  End Impl_ubt_embedding_AccountStem.
End embedding.
