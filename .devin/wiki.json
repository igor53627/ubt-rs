{
  "repo_notes": [
    {
      "content": "This is a Unified Binary Tree (UBT) implementation for Ethereum's EIP-7864 state tree. The project has two main components: a Rust implementation in src/ and formal verification proofs in Rocq/Coq in formal/. The Rust code provides a production-ready tree structure with Blake3 hashing, while the formal verification proves correctness properties.",
      "author": "maintainer"
    },
    {
      "content": "Key architectural layers: 1) Rust implementation (src/tree.rs, src/hasher.rs) - the actual tree with stems, leaves, and incremental updates. 2) Simulation layer (formal/simulations/) - abstract Coq model of tree operations. 3) Specification layer (formal/specs/) - EIP-7864 formal spec. 4) Linking layer (formal/linking/) - connects Rust translation to Coq proofs via RocqOfRust.",
      "author": "maintainer"
    },
    {
      "content": "The tree uses a 248-bit key space with stems (31 bytes) and subindices (1 byte). Each stem can hold up to 256 values. The implementation supports both full rebuild mode (O(S log S)) and incremental mode for block execution. Verkle polynomial commitments are planned but cryptographic primitives are currently axiomatized.",
      "author": "maintainer"
    },
    {
      "content": "Linking layer architecture (PR #47): 5-layer OpExec architecture for proof decomposition - L1: Pure stepping (proven), L2: Simulation decomposition (proven), L3: Data structure stepping (axioms), L4: Composition (axioms), L5: Operation theorems (proven from L4). delete_executes is fully proven by reducing to insert with zero32.",
      "author": "maintainer"
    },
    {
      "content": "Key modules in linking layer: 1) RunFuelLink - connects abstract Run.run to concrete Fuel.run execution, 2) TraitRegistry - hasher trait resolution (Sha256, Blake3), 3) HashMapLink - HashMap/SubIndexMap correspondence, 4) BatchStepping - fold-based batch verification, 5) RootHashLink - node hash stepping for Merkle root computation.",
      "author": "maintainer"
    },
    {
      "content": "Monad laws status (PR #55): Laws.run_pure and Laws.run_panic are PROVEN via reflexivity after simpl. step_let is split into step_let_pure (computable, covers Pure cases) and step_let_nonpure (axiom, for mutual recursion with step).",
      "author": "maintainer"
    },
    {
      "content": "Fuel determinism (PR #56): Fuel.run_success_unique PROVEN by induction on fuel. SmallStep.step is a function so Fuel.run is deterministic. InsertExec.insert_fuel_refines_simulation PROVEN using fuel determinism.",
      "author": "maintainer"
    },
    {
      "content": "Monad bind axiom (PR #57): Laws.let_sequence promoted to explicit [AXIOM:MONAD-BIND]. MonadLaws.run_bind_fuel PROVEN using axiom. BatchStepping.batch_fold_short_circuit PROVEN via induction + let_sequence.",
      "author": "maintainer"
    },
    {
      "content": "Prior cleanup (PR #58): FuelExec.run_fuel_implies_run REMOVED (was duplicate of RunFuelLink.run_fuel_implies_run_v2). Admitted reduced from 2 to 1.",
      "author": "maintainer"
    },
    {
      "content": "Zero Admitted achieved (PR #59): RootHashLink.root_hash_executes_sketch PROVEN by deriving from HashLink.root_hash_executes + Run/Fuel bridging axioms. Semantic gap remains at HashLink.root_hash_executes axiom (operations.v). Admitted count: 0 (down from 10 initially).",
      "author": "maintainer"
    }
  ],
  "pages": [
    {
      "title": "Overview",
      "purpose": "High-level introduction to UBT-RS: what it is, why it exists (EIP-7864), and how the Rust implementation relates to the formal verification"
    },
    {
      "title": "Rust Implementation",
      "purpose": "Document the core Rust code in src/: UnifiedBinaryTree struct, StemNode, TreeKey, insert/get/delete operations, and the hasher trait",
      "parent": "Overview"
    },
    {
      "title": "Tree Operations",
      "purpose": "Explain insert, get, delete, and root_hash operations. Cover both full rebuild and incremental update modes with complexity analysis",
      "parent": "Rust Implementation"
    },
    {
      "title": "Incremental Mode",
      "purpose": "Document enable_incremental_mode(), the node hash cache, dirty stem tracking, and when to use incremental vs full rebuild. Reference docs/incremental-updates.md",
      "parent": "Rust Implementation"
    },
    {
      "title": "Formal Verification",
      "purpose": "Overview of the Rocq/Coq formal verification in formal/. Explain the proof architecture: specs, simulations, proofs, and linking layers",
      "parent": "Overview"
    },
    {
      "title": "Simulation Layer",
      "purpose": "Document formal/simulations/: tree.v (abstract tree model), crypto.v (hash axioms), and the simulation proofs",
      "parent": "Formal Verification"
    },
    {
      "title": "Specification Layer",
      "purpose": "Document formal/specs/: tree_spec.v and embedding_spec.v that formalize EIP-7864 requirements",
      "parent": "Formal Verification"
    },
    {
      "title": "Linking Layer",
      "purpose": "Explain formal/linking/: how RocqOfRust translates Rust to Coq and how behavioral equivalence is established via *_executes axioms",
      "parent": "Formal Verification"
    },
    {
      "title": "Axiom Audit",
      "purpose": "Summarize the axiom count (currently ~85), categorization (crypto, verkle, linking, spec), and trust assumptions. Reference formal/docs/axiom_audit.md",
      "parent": "Formal Verification"
    },
    {
      "title": "OpExec Architecture",
      "purpose": "Document the 5-layer OpExec architecture in interpreter.v: Layer 1 (pure stepping), Layer 2 (simulation decomposition), Layer 3 (data structure axioms), Layer 4 (composition axioms), Layer 5 (operation theorems). Explain how delete_executes is proven.",
      "parent": "Linking Layer"
    },
    {
      "title": "RunFuelLink",
      "purpose": "Document the RunFuelLink module that connects abstract Run.run (Parameter) to concrete Fuel.run execution. Cover state conversion, sufficient_fuel_exists axiom, and fuel_success_implies_run axiom.",
      "parent": "Linking Layer"
    },
    {
      "title": "Batch Verification",
      "purpose": "Document batch verification linking: BatchVerifyLink in operations.v and BatchStepping in interpreter.v. Cover fold-based verification, multiproof support, and composition lemmas.",
      "parent": "Linking Layer"
    },
    {
      "title": "Monad Laws",
      "purpose": "Document the Laws and MonadLaws modules in interpreter.v. Cover run_pure, run_panic (proven), let_sequence (semantic axiom). Explain the step_let split into pure (Definition) and nonpure (Parameter) parts. Reference Issues #48-#54.",
      "parent": "Linking Layer"
    },
    {
      "title": "Fuel Determinism",
      "purpose": "Document Fuel.run_success_unique lemma. Explain how SmallStep.step being a function implies Fuel.run is deterministic. Show how this enables proving theorems from execution axioms (e.g. insert_fuel_refines_simulation).",
      "parent": "Linking Layer"
    },
    {
      "title": "QuickChick Testing",
      "purpose": "Document the property-based testing in formal/proofs/quickchick_tests.v: the 5 properties tested, generators, and CI integration",
      "parent": "Formal Verification"
    },
    {
      "title": "Build and CI",
      "purpose": "Document how to build the project: cargo commands for Rust, make targets for formal proofs, and the CI workflows in .github/workflows/",
      "parent": "Overview"
    },
    {
      "title": "Architecture Diagram",
      "purpose": "Visual diagram showing the relationship between Rust code, RocqOfRust translation, linking layer, simulation layer, and specifications"
    }
  ]
}
