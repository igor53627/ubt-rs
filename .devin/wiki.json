{
  "repo_notes": [
    {
      "content": "This is a Unified Binary Tree (UBT) implementation for Ethereum's EIP-7864 state tree. The project has two main components: a Rust implementation in src/ and formal verification proofs in Rocq/Coq in formal/. The Rust code provides a production-ready tree structure with Blake3 hashing, while the formal verification proves correctness properties.",
      "author": "maintainer"
    },
    {
      "content": "Key architectural layers: 1) Rust implementation (src/tree.rs, src/hasher.rs) - the actual tree with stems, leaves, and incremental updates. 2) Simulation layer (formal/simulations/) - abstract Coq model of tree operations. 3) Specification layer (formal/specs/) - EIP-7864 formal spec. 4) Linking layer (formal/linking/) - connects Rust translation to Coq proofs via RocqOfRust.",
      "author": "maintainer"
    },
    {
      "content": "The tree uses a 248-bit key space with stems (31 bytes) and subindices (1 byte). Each stem can hold up to 256 values. The implementation supports both full rebuild mode (O(S log S)) and incremental mode for block execution. Verkle polynomial commitments are planned but cryptographic primitives are currently axiomatized.",
      "author": "maintainer"
    },
    {
      "content": "Linking layer architecture (PR #47): 5-layer OpExec architecture for proof decomposition - L1: Pure stepping (proven), L2: Simulation decomposition (proven), L3: Data structure stepping (axioms), L4: Composition (axioms), L5: Operation theorems (proven from L4). delete_executes is fully proven by reducing to insert with zero32.",
      "author": "maintainer"
    },
    {
      "content": "Key modules in linking layer: 1) RunFuelLink - connects abstract Run.run to concrete Fuel.run execution, 2) TraitRegistry - hasher trait resolution (Sha256, Blake3), 3) HashMapLink - HashMap/SubIndexMap correspondence, 4) BatchStepping - fold-based batch verification, 5) RootHashLink - node hash stepping for Merkle root computation.",
      "author": "maintainer"
    },
    {
      "content": "Monad laws status (PR #55): Laws.run_pure and Laws.run_panic are PROVEN via reflexivity after simpl. step_let is split into step_let_pure (computable, covers Pure cases) and step_let_nonpure (axiom, for mutual recursion with step).",
      "author": "maintainer"
    },
    {
      "content": "Fuel determinism (PR #56): Fuel.run_success_unique PROVEN by induction on fuel. SmallStep.step is a function so Fuel.run is deterministic. InsertExec.insert_fuel_refines_simulation PROVEN using fuel determinism.",
      "author": "maintainer"
    },
    {
      "content": "Monad bind axiom (PR #57): Laws.let_sequence promoted to explicit [AXIOM:MONAD-BIND]. MonadLaws.run_bind_fuel PROVEN using axiom. BatchStepping.batch_fold_short_circuit PROVEN via induction + let_sequence.",
      "author": "maintainer"
    },
    {
      "content": "Prior cleanup (PR #58): FuelExec.run_fuel_implies_run REMOVED (was duplicate of RunFuelLink.run_fuel_implies_run_v2). Admitted reduced from 2 to 1.",
      "author": "maintainer"
    },
    {
      "content": "Linking layer Zero Admitted (PR #59): RootHashLink.root_hash_executes_sketch PROVEN by deriving from HashLink.root_hash_executes + Run/Fuel bridging axioms. Linking layer (formal/linking/) has 0 Admitted. Project totals: 697 Qed, 82 Admitted (79 in RocqOfRust-generated src/, 3 in specs), 155 axioms.",
      "author": "maintainer"
    },
    {
      "content": "SmallStep expansion (Issue #60): 4 LowM constructors now implemented as pure Definitions: step_if_then_else (boolean branching), step_match_tuple (tuple destructuring), step_logical_op (short-circuit && ||), step_let_alloc_pure (heap allocation). Previously returned Stuck, now fully operational.",
      "author": "maintainer"
    },
    {
      "content": "Panic freedom analysis (Issue #60): Rust code review confirms get/insert/delete have NO panic paths (use Option-returning HashMap methods). root_hash has depth=248 panics but they're UNREACHABLE because stems are 31 bytes (248 bits) and recursion terminates when stem count <= 1.",
      "author": "maintainer"
    },
    {
      "content": "Laws.let_pure monad law (Issue #60): Added left-identity law M.let_ (M.pure v) f = f v. Fixed last remaining Admitted in operations.v. Zero Admitted in linking layer.",
      "author": "maintainer"
    },
    {
      "content": "Predicate closure stepping (Issue #60): step_predicate_closure handles |&b| b == 0 patterns. CompareOp: CmpEq/CmpLt/CmpGt. 5 correctness lemmas proven. Supports .all()/.any() iterator patterns.",
      "author": "maintainer"
    },
    {
      "content": "HashMap stepping axioms (Issue #60): hashmap_insert_steps + hashmap_insert_then_get_steps axioms. 3 proven correctness lemmas: get_after_set_same, get_after_set_other, hashmap_get_after_insert. Models HashMap as LowM.CallPrimitive + LowM.CallClosure.",
      "author": "maintainer"
    },
    {
      "content": "Linking layer complete (PR #61): All 11 linking layer files compile successfully. New modules: field_stepping.v (struct field access), get_stepping.v/insert_stepping.v (operation derivations), iterator_stepping.v (HashMap/drain proofs), root_hash_stepping.v (Merkle root), axiom_elimination.v (proven fuel lemmas), tree_build_stepping.v (streaming construction).",
      "author": "maintainer"
    },
    {
      "content": "Axiom status (PR #61): 155 total axioms (25 irreducible in linking layer documented in AXIOM_CATALOG.md, rest from RocqOfRust-generated code). Linking layer categories: Monad Laws (2), Termination (2), HashMap (6), Trait Resolution (3), State/Purity (5), Batch Verification (4), Stdlib (2). All linking axioms have risk assessments and mitigation strategies.",
      "author": "maintainer"
    },
    {
      "content": "FieldStepping module (PR #61): step_field_read for reading struct fields, read_stems_field theorem (proven), stems_field_in_tree lemma. Enables get_stepping.v and insert_stepping.v to extract stems from tree values matching tree_refines.",
      "author": "maintainer"
    },
    {
      "content": "rocq-of-rust-interp library (PR #61): General-purpose M monad interpreter extracted to https://github.com/igor53627/rocq-of-rust-interp. Integrated as git submodule at formal/lib/rocq-of-rust-interp. Provides reusable stepping infrastructure for any RocqOfRust project.",
      "author": "maintainer"
    },
    {
      "content": "Session work (December 2024): 1) Created rocq-of-rust-interp#1 issue for full M monad interpreter. 2) Added 6 new QuickChick iterator properties (P32-P37). 3) Fixed CodeRabbit PR #61 feedback: test counts, trivial properties, wiki metrics, error handling. 4) All metrics aligned: 641 Qed, 185 Axioms (45 in linking), 0 Admitted in linking layer (82 total in src/specs). 5) Build verified: 22 CI QuickChick tests pass.",
      "author": "maintainer"
    },
    {
      "content": "MRun and FuelBridge modules (PR #63 cont.): 1) MRun.v (389 lines) - relational execution semantics with Run.run_ok predicate, State/Config types, SmallStep evaluation, Fuel-bounded execution, proven Laws module. 2) fuel_bridge.v (187 lines) - bridges interpreter.Fuel to MRun.Fuel with state/config/outcome conversions and round-trip lemmas. 3) Updated *_stepping.v files to use Run.run_ok instead of Run.run function. 4) Converted 2 field_stepping axioms to theorems via M.pure pattern.",
      "author": "maintainer"
    }
  ],
  "pages": [
    {
      "title": "Overview",
      "purpose": "High-level introduction to UBT-RS: what it is, why it exists (EIP-7864), and how the Rust implementation relates to the formal verification"
    },
    {
      "title": "Rust Implementation",
      "purpose": "Document the core Rust code in src/: UnifiedBinaryTree struct, StemNode, TreeKey, insert/get/delete operations, and the hasher trait",
      "parent": "Overview"
    },
    {
      "title": "Tree Operations",
      "purpose": "Explain insert, get, delete, and root_hash operations. Cover both full rebuild and incremental update modes with complexity analysis",
      "parent": "Rust Implementation"
    },
    {
      "title": "Incremental Mode",
      "purpose": "Document enable_incremental_mode(), the node hash cache, dirty stem tracking, and when to use incremental vs full rebuild. Reference docs/incremental-updates.md",
      "parent": "Rust Implementation"
    },
    {
      "title": "Formal Verification",
      "purpose": "Overview of the Rocq/Coq formal verification in formal/. Explain the proof architecture: specs, simulations, proofs, and linking layers",
      "parent": "Overview"
    },
    {
      "title": "Simulation Layer",
      "purpose": "Document formal/simulations/: tree.v (abstract tree model), crypto.v (hash axioms), and the simulation proofs",
      "parent": "Formal Verification"
    },
    {
      "title": "Specification Layer",
      "purpose": "Document formal/specs/: tree_spec.v and embedding_spec.v that formalize EIP-7864 requirements",
      "parent": "Formal Verification"
    },
    {
      "title": "Linking Layer",
      "purpose": "Explain formal/linking/: how RocqOfRust translates Rust to Coq and how behavioral equivalence is established via *_executes axioms",
      "parent": "Formal Verification"
    },
    {
      "title": "Axiom Audit",
      "purpose": "Summarize axiom counts: 185 total (45 in linking layer, 25 irreducible; rest from RocqOfRust-generated code). Categorization of linking axioms (monad, termination, hashmap, trait resolution, state, batch, stdlib), and trust assumptions. Reference formal/docs/AXIOM_CATALOG.md",
      "parent": "Formal Verification"
    },
    {
      "title": "OpExec Architecture",
      "purpose": "Document the 5-layer OpExec architecture in interpreter.v: Layer 1 (pure stepping), Layer 2 (simulation decomposition), Layer 3 (data structure axioms), Layer 4 (composition axioms), Layer 5 (operation theorems). Explain how delete_executes is proven.",
      "parent": "Linking Layer"
    },
    {
      "title": "RunFuelLink",
      "purpose": "Document the RunFuelLink module that connects abstract Run.run (Parameter) to concrete Fuel.run execution. Cover state conversion, sufficient_fuel_exists axiom, and fuel_success_implies_run axiom.",
      "parent": "Linking Layer"
    },
    {
      "title": "Batch Verification",
      "purpose": "Document batch verification linking: BatchVerifyLink in operations.v and BatchStepping in interpreter.v. Cover fold-based verification, multiproof support, and composition lemmas.",
      "parent": "Linking Layer"
    },
    {
      "title": "Monad Laws",
      "purpose": "Document the Laws and MonadLaws modules in interpreter.v. Cover run_pure, run_panic (proven), let_sequence (semantic axiom). Explain the step_let split into pure (Definition) and nonpure (Parameter) parts. Reference Issues #48-#54.",
      "parent": "Linking Layer"
    },
    {
      "title": "Fuel Determinism",
      "purpose": "Document Fuel.run_success_unique lemma. Explain how SmallStep.step being a function implies Fuel.run is deterministic. Show how this enables proving theorems from execution axioms (e.g. insert_fuel_refines_simulation).",
      "parent": "Linking Layer"
    },
    {
      "title": "QuickChick Testing",
      "purpose": "Document the property-based testing in formal/proofs/quickchick_tests.v: the 5 properties tested, generators, and CI integration",
      "parent": "Formal Verification"
    },
    {
      "title": "Build and CI",
      "purpose": "Document how to build the project: cargo commands for Rust, make targets for formal proofs, and the CI workflows in .github/workflows/",
      "parent": "Overview"
    },
    {
      "title": "Architecture Diagram",
      "purpose": "Visual diagram showing the relationship between Rust code, RocqOfRust translation, linking layer, simulation layer, and specifications"
    },
    {
      "title": "Field Stepping",
      "purpose": "Document field_stepping.v: step_field_read for struct field access, read_stems_field theorem, and how tree_refines enables extracting stems from encoded trees",
      "parent": "Linking Layer"
    },
    {
      "title": "Iterator Stepping",
      "purpose": "Document iterator_stepping.v: HashMap iteration proofs, drain stepping, for_each stepping, and how Permutation captures unordered iteration",
      "parent": "Linking Layer"
    },
    {
      "title": "Axiom Elimination",
      "purpose": "Document axiom_elimination.v: fuel_success_monotone, fuel_success_implies_run proofs, and the computation_bounded axiom for termination bounds",
      "parent": "Linking Layer"
    },
    {
      "title": "MRun Module",
      "purpose": "Document MRun.v: Relational execution semantics for M monad with Run.run_ok predicate. State/Config types matching MInterpreter, SmallStep evaluation with extension points, Fuel-bounded execution, proven Laws module (run_pure, run_panic, fuel_monotonic, success_precludes_panic).",
      "parent": "Linking Layer"
    },
    {
      "title": "FuelBridge Module",
      "purpose": "Document fuel_bridge.v: Bridge between interpreter.Fuel and MRun.Fuel. State/config/outcome conversion functions with proven round-trip lemmas. Key theorem: interpreter_fuel_to_run_ok connects Fuel.run success to Run.run_ok.",
      "parent": "Linking Layer"
    }
  ]
}
